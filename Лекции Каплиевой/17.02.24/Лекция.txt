Умные указатели в классах и структурах


Unique_ptr можно использовать в качестве члена композиции класса, в явном виде деструктор писать не нужно,
т.к. unqiue ptr будет уничтожен автоматически при уничтожении объекта класса.
Тем не менее, если объект класса выделяется динамически, то сам ресурс unique поинтера подвергается риску
неправильного удаления, и в этом случае даже умный указатель не обеспечивает правильное удаление ресурсов.


Существует 2 способа неправильного использования unqiue ptr:
1. Нельзя позволять нескольким классам (unique ptr) владеть одним и тем же ресурсом.
int *ptr_int = new int(5);
std::unique_ptr<int> ptr1(ptr_int);
std::unique_ptr<int> ptr2(ptr_int); // Хоть это и синтаксически верно, 
     // но при явной передаче мы сделали 2 умных указателя на другой ресурс, и ни один из них не знает
     // про другой ресурс. Когда программа завершается, вызывается деструктор для ptr_int через первый ресурс,
     // потом будет попытка вызывать тот же деструктор через другой ресурс.
     
2. Никогда не удалять выделенный ресурс вручную.
std::unique_ptr<int> ptr1(ptr_int);
delete ptr_int; // аварийное завершение работы (непредвиденное поведение)

Функция make_unqiue предовтращает непреднамеренное возникновение обеих ситуаций:
std::unique_ptr<int> ptr1 = std::make_unique<int>(*ptr_int);
std::unique_ptr<int> ptr2 = std::make_unique<int>(*ptr_int);




                                    Умный указатель Shared pointer
В отличие от unique_ptr, shared_ptr предназначен для случаев, когда несколько умных указателей совместно владеют
одним динамически выделенным ресурсом. Этот умный указатель отслеживает количество владельцев у каждого 
полученного ресурса. Пока хотя бы один shared_ptr владеет ресурсом, этот ресурс не будет уничтожен,
даже если остальные shared_ptr удалить. Это правило единоличного владения встречается в параллельном программировании.
Как только последний shared_ptr, владеющий ресурсом, выйдет из области видимости или ему передадут другой ресурс
для управления, исходный ресурс будет уничтожен.

Важно, что второй умный указатель создаётся из первого (тогда корректно работает счётчик ресурсов).
В следующем примере будет сгенерировано исключение, т.к. создаётся 2 отдельных независимых друг от друга
Shared поинтера, т.к. они ничего не знают друг о друге, поэтому когда shared_ptr2 выходит из области видимости,
он деструктурирует ptr_int, а когда shared_ptr1 выйдет из своей области видимости, то произойдёт аварийное
завершение работы (ptr_int уже был удалён):
int *ptr_int = new int(5);
std::shared_ptr<int> ptr1(ptr_int);
{
    std::shared_ptr<int> ptr2(ptr_int);
}

Правило: всегда выполнять копирование (если нужно, то более одного) shared_ptr, указывающего на
один и тот же динамически выделенный ресурс.


                                        Функция std::make_shared

int *ptr_int = new int(5);
std::shared_ptr<int> ptr1 = std::make_shared<int>(*ptr_int);
{
    auto ptr2 = ptr1;
    std::cout << ptr_int << '\n'; // адрес 1
    std::cout << ptr1.get() << '\n'; // адрес 2
    std::cout << ptr2.get() << '\n';  // адрес 2
}
delete ptr_int; // теперь возможно удаление динамической памяти


                                    Создание shared_ptr из unique_ptr
Умный указатель unique_ptr может быть конвертирован в умный указатель shared_ptr через передачу владения (std::move)
и через функцию, возвращающую unique_ptr

Примеры:
------------------------------------------------------

std::unique_ptr<int> ptr1 = std::make_unique<int>(5);
// std::shared_ptr<int> ptr2 = ptr1; // синтаксическая ошибка! 
std::shared_ptr<int> ptr2 = std::move(ptr1); // верно

------------------------------------------------------

std::unique_ptr<int> function(int x)
{
    // return std::unique_ptr<int>(new int(x));
    return std::make_unique<int>(x);
}

int main()
{
    std::unique_ptr<int> ptr1 = function(5);
    std::unique_ptr<int> ptr2 = function(7);
}
------------------------------------------------------

                                                Особенности shared_ptr
 У умного укзателя shared_ptr есть некоторые из проблем, которые имеет unique_ptr:
 1. Если shared_ptr не уничтожается должным образом (либо потому что он был динамически выделен и не удалён должным образом,
 либо он был частью объекта, который был динамически выделен и не удалён), то ресурс тоже может быть не освобождён и останется в куче.
С unique_ptr нужно беспокоиться об удалении одного указателя, однако с shared_ptr придётся беспокоиться об удалении всех указателей .



                                                Shared_ptr и массивы
С 14 версии С++ появились shared_ptr, которые могут управлять динамическими массивами, а с 17 стандарта добавили поддержку
обработки динамических массивов, однако в 17 стандарте "забыли" добавить поддержку динамических массивов через make_shared, 
поэтому эту функцию не следует использовать для создания динамического массива под управлением shared_ptr.

std::unique_ptr<int[]> arr1(new int[10]);
auto arr2 = std::make_unique<int[]>(10);
std::shared_ptr<int[]> arr2(new int[10], std:: default_delete<int[]>()); // в 17 стандарте задавать только так



С помощью умного указателя shared_ptr несколько умных указателей могут владеть одним динамически выделенным ресурсом,
однако в этой ситуации может возникнуть пересечение умных указателей.
Пример:

struct ELEM
{
    char ch;
    std::shared_ptr<ELEM> sh_ptr;

    ELEM(char ch): ch(ch)
    {
        std::cout << "elem " << ch << " created\n";
    }

    ~ELEM()
    {
        std::cout << "elem " << ch << " destroyed\n";
    }

    void set_ptr(std::shared_ptr<ELEM> ptr)
    {
        sh_ptr = ptr;
    }
};

int main()
{
    {
        std::shared_ptr<ELEM> elemA = std::make_shared<ELEM>('a');
        auto elemB = std::make_shared<ELEM>('b');
        elemA->set_ptr(elemB); 
        elemB->set_ptr(elemA); // перекрёстное владение указателей
    }
    return 0;
}   

В данном примере указатели shared_ptr формируют циклическую зависимость.



                                                Упрощённая циклическая зависимость
Проблема циклической ссылки может возникнуть даже с одним умным указателем shared_ptr. Такая циклическая зависимость называется упрощённой.
Пример:

std::shared_ptr<ELEM> elemC = std::make_shared<ELEM>('c');
elemC->set_ptr(emelC); 



                                                Умный указатель weak
Weak_ptr был разработан для решения проблемы циклической зависимости. Weak_ptr является наблюдателем, а не владельцем ресурса.
Он может наблюдать и получать доступ к тому же объекту, на который указывает shared_ptr или другой weak_ptr. Когда shared_ptr
выходит из области видимости, он проверяет, есть ли другие владельцы с shared_ptr (но не weak_ptr).
Решение предыдущей проблемы:
struct ELEM
{
    char ch;
    std::weak_ptr<ELEM> sh_ptr; // здесь 

    ELEM(char ch): ch(ch)
    {
        std::cout << "elem " << ch << " created\n";
    }

    ~ELEM()
    {
        std::cout << "elem " << ch << " destroyed\n";
    }

    void set_ptr(std::shared_ptr<ELEM> ptr)
    {
        sh_ptr = ptr;
    }

    std::shared_ptr<ELEM> get_ptr() const 
    {
            return sh_ptr.lock();
    }
};

Когда elemA выходит из области видимости, он видит, что нет другого shared_ptr (weak владельцем не считается),
поэтому elemA уничтожается, аналогично деструктурируется elemB. 

Недостатком weak_ptr явялется невозможность его использования напрямую, т.к. для него не определён оператор "->". 
Чтобы использовать weak_ptr, необходимо его сначала конвертировать в shared_ptr с помощью метода lock, а затем уже
использовать содержимое по указателю:

std::weak_ptr<ELEM> elemA = std::make_shared<ELEM>('a');
auto elemB =  std::make_shared<ELEM>('b');
std::cout << elemA->sh_ptr.lock()->ch;

Или можно через метод класса get_ptr:

std::cout << elemA->sh_ptr->get_ptr();
