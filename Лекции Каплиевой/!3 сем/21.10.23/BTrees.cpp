/*
Если количество потомков варьируется,
то их количество задаём с помощью однонаправленного списка.
Подобные структуры быстро разрастаются
в сложный реляционный банк данных, в котором можно выделить несколько деревьев.
Алгоритмы, работающие с такими структурами, существенно зависят от их описаний,
поэтому для них не определяют общих правил и приёмов работы.
Одна из практических областей применения сильно ветвящихся деревьев -
формирование и поддержание крупномасштабных деревьев поиска,
в которых необходимо:
1) поиск;
2) включение;
3) удаление элементов, но только для которых либо не хватает оперативной памяти,
либо (память) слишком дорога для долговременного хранения элементов.
Вместо Node будем называть один узел Page (страницей).

Было придумано дерево, в котором можно контролировать расположение потмков.
Б-дерево:
1. Каждая страница, кроме одной - корневой - должна содержать от n до 2n вершин, где
n - некоторая константа, рассчитываемая в зависимости от количества ключей,
размещаемых на странице.
2. Значение n называется порядком б-дерева.
3. N - количество узлов, которое хранится в б-дереве.
4. Количество обращений к страницам = log n (N).

m - фактическое количество ключей.
*/

/*
ЗАДАНИЕ:
Написать структуру B-tree,  в которй нужно описать процедуру добавления в дерево,
печать и поиск.
*/

#include "BTrees.h"

int main()
{
    std::cin.get();
    return 0;
}