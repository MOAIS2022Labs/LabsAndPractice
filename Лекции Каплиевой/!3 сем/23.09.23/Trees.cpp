#include <iostream>
/*
В лабе создать контейнер, котоырй хранит поле root.
Должны быть функции создания, печати и удаления дерева.
--------------------------------------------------


1. ДЕРЕВО - это абстрактный тип данных для хранения информационных элементов,
имеющих нелинейные отношения. 
За исключением элемента, который находится во главе дерева,
каждый элемент имеет родителя, а также 0 или более дочерних потоков.

2. Каждый элемент в дереве называется ВЕРШИНОЙ (узлом дерева).
Вершины соединены направленными дугами, называемыми ветвями.

3. Начальный узел называется КОРНЕМ; элемент, который не имеет потомков,
называется ЛИСТОМ (терминальным); остальные элементы называются ВНУТРЕННИМИ.

4. Каждое дерево обладает свойством: существует узел, в который не входит ни одной дуги,
и в каждую вершину, кроме корня, входит одна дуга.

5. СТЕПЕНЬЮ ВЕРШИНЫ в дереве называется количество дуг, которое из неё выходит.
Степень дерева равна максимальной степени вершины.

6. По степени различают 2 типа деревьев: ДВОИЧНЫЕ (бинарные) и СИЛЬНО ВЕТВЯЩИЕСЯ (степень дерева произвольная).

7. ВЫСОТА  (глубина) дерева опрелеляется количеством уровней, на которых располагаются его вершины.
Высота пустого дерева равна 0. Нумеруются уровни начиная с 0.

8. Число ветвей, которое нужно пройти от корня к узлу, называется ДЛИНОЙ ПУТИ.

9. ПОДДЕРЕВО - часть древообразной структуры, которое может быть представлено в виде отдельного поддерева.

10. Для того, чтобы выполнить операцию над всеми вершинами дерева, необходимо просмотреть его вершины.
Такая задача называется обходом дерева. 
ОБХОД ДЕРЕВА - это упорядоченная последовательность вершин дерева, в которой каждая вершина встречается только один раз.
При обходе все вершины должны посещаться в определённом порядке.
Существует 3 наиболее часто используемых способов обхода дерева:
1) прямой (префиксный) обход "PreOrder" - предварительно узел, потом потомки;
2) симметричный (инфиксный) обход "InOrder" - узел будет обрабатываться в середине: сначала все левые потомки, потом все правые;
3) обратный (постфиксный) обход "PostOrder" - узел обрабаывается посел своих потомков.

Где на практике используются деревья: 
1) при разработке парсеров - программы, которая используется для сбора информации с сайтов
 для последующего размещения на собственных ресурсах, или трансляторов для построения деревьев синтаксического разбора;
2) суффиксное дерево - при работе с текстовой информацией;
3) при разработке оптимальных алгоритмов на графах - структуры данных в виде кучи 
(куча - это дерево, в которой каждому объекту присваивается приоритет; на верху кучи находится объект с макс. приоритетом);
4) при реализации словарей (быстрых поисковых систем) используется довичное дерево поиска.

В общем случае, у бинарного дерева на k-ом уровне не более, чем 2^k потомков.
Бинарное дерево называется полным, если она содержит только полностью заполненные уровни,
в противном случае - дерево неполное.

ДЕРЕВОМ ПОИСКА называется дерево, у которого для каждой вершины выполняется следующее требование:
значение ключей в левом поддереве меньше значения ключей в вершине,
значенией ключей в правом поддереве строго больше значения ключа в родителськом узле.

ИДЕАЛЬНО СБАЛАНСИРОВАННЫМ называется дерево, у которого для каждой вершины выполняется требование:
число вершин в левом и правом поддеревьях отличается не более, чем на 1.

СБАЛАНИСРОВАННОЕ ДЕРЕВО ПО АВЛ: 
1) высота левого и правого поддеревьев отличается не более, чем на 1;
2) дерево должно быть деревом поиска (???).
*/
int main()
{
    std::cin.get();
    return 0;
}