namespace TransportationLab2
{
    #region Общее описание задания
    /*
    Задание 2
    Цель — создание модели, описывающей процесс, построение иерархии классов,
    отражающей данную предметную область.
    
    По действиям пользователя
    следует создавать экземпляры классов иерархии. Использовать исключения. 

    Разработать класс менеджера, позволяющего создавать, 
    уничтожать и модифицировать объекты (в некоторых задачах — динамика от таймера).

    Для каждой задачи необходимо реализовать объектную модель. 
    В реализации задач должны присутствовать наследование, агрегация и др.
    взаимодействия классов.
    
    Интерфейс к задаче необходимо выполнить на
    WinForms с использованием компонентов. Для отображения использовать
    2D-графику или графические элементы управления. 
    
    Формы и компоненты используются только для отображения и ввода данных, 
    но не для хранения объектов. Использовать исключения (exceptions).
    */
    #endregion

    #region Требования
    /*
    Требования к реализации.
     Приложение реализовать как MVC. Модель — иерархия классов.
    View — демо в автоматическом режиме.
     Действующие объекты должны быть реализованы как 
    потоки с необходимой синхронизацией.
     Для оповещения об изменениях использовать 
    шаблон «Наблюдатель».
     Для создания действующих объектов 
    использовать шаблон «Фабрика».
     Использование других шаблонов приветствуется.*/
    #endregion

    #region Условие
    /*
    10. Грузоперевозки. Основные сущности: автомашины, города,
    между которыми осуществляются перевозки, сеть дорог, грузы,
    их типы, клиенты. Смоделировать процесс перевозки грузов.
    */
    #endregion

    #region Моя идея логики работы лабы
    /*
    1. Автомашины - тут всё просто: есть интерфейс автомашины и класс, который его реализует.
    Его полями пусть будут марка машины, регистрационный номер, грузоподъёмность, грузы, которые туда поместили,
    точка назначения
    2. Города - просто перечислитель с городами
    3. Дороги - всё так же: поля - это город отправки и город доставки, а также протяжённость.
    За счёт протяжённости будет меняться время доставки (сколько поток будет "спать" + длительность анимации)
    4. Грузы и их типы - самое интересное.
    Здесь как раз и реализуется паттерн "Фабрика", потому что типов может быть несколько.
    Будет интерфейс для типа груза (в папке Unit), а также интерфейс для билдера (в папке Fabric).
    Дальше понятно, что согласно данному патерну нужно будет создать отдельные классы, которые 
    выражают сам тип груза, а также их соответствующе порождающие (те самые билдеры).
    Пример: есть интерфейс ICargoType и для него ICargoTypeBuilder, потом конкретные классы пошли:
    Fragile (и FragileBuilder), Heavy (и HeavyBuilder) и т.д. ...
    Насчёт полей: будет определено название груза, его вес, стоимость доставки, куда доставляют,
    сведения о клиенте и т.д. 
    5. Клиенты - здесь всё просто: ФИО, город, что получает, сколько платит за доставку (продумать точно)
    
    Насчёт паттерна наблюдатель всё очень размыто, но идея примерно ясна. 
    Известно, что данный шаблон реализует связь "один-ко-многим", т.е. 
    при изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей.
    Предполагаю, что тут всё на событиях будет работать, так что париться особо с реализацией не надо будет.
    
    Ещё есть такой прикол: хотя паттерн наблюдателя на .NET можно реализовать с помощью событийной модели, 
    однако есть те, кто рекомендует использовать простую реализацию на классах, чтобы можно было это воплотить 
    на любом другом языке (т.к. события на шарпах - это местный сахар, который не везде есть).
    Мне лично всё равно, что там советуют, потому что синтаксис событий удобнее + не надо будет
    маяться с лишними классами.
    
    Но если кто-то решил заняться садомазохизмом, то вот инструкция, как это воплотить:
    Я бы начал с созданием отдельного класса с названием типа Message (класс для уведомлений), 
    который будет уведомлять нашего клиента (это наблюдатель, реализует IObserver<Message>)
    при успешной доставке груза (наблюдаемый объект, или же IObservable<Message>).
    */
    #endregion

    #region Взаимодейстие клиента и доставщика
    /*
    Что будем делать:
    1. Добавить грузовики: максимально - 4 шт.
    2. Добавить клиентов (в идеале, один клиент в одном городе, но
    можно попытаться и реализовать двух и более клиентов): максимально - 4 шт.
    3. Добавить заказы для случайных клиентов и таким же случайным образом
    распределить грузы между авто. Заказ назначается грузовику в следующих случаях:
    -случайным образом выбирается не занятый грузовик;
    -если все заняты, то грузовик отбирается случайно из общего числа.
    4. Процесс доставки начинается тогда, когда в авто были погружены необходимые заказы.
    У каждого грузовика есть очередь клиентов, которым надо доставить груз.
    Когда клиент попадает в данную очередь, он подписывается на event, который
    в будущем уведомит его о доставке и запустит (через Invoke) процесс передачи заказа 
    (условно будет это будет функция GetOrder, изменяющая статус заказа клиента на
    "доставлен"). После доставки клиент отписывается от данного event.
    Сам процесс работы грузовиков является параллельным, т.е. несколько грузовиков независимо 
    друг от друга могут доставлять клиентам грузы.
    */
    #endregion
    internal static class Program   
    {
        [STAThread]
        static void Main()
        {
            ApplicationConfiguration.Initialize();
            Application.Run(new MainForm());
        }
    }
}