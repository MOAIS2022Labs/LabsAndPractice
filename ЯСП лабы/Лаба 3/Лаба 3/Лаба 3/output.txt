} result; return --size; ++head; front(); = result T { Deque<T>::pop_front() T inline T> template<typename } result; return --size; --tail; back(); = result T { Deque<T>::pop_back() T inline T> template<typename } '\n'; << std::cout пустой!"; "Дек << std::cout else '; ' << data[i] << std::cout ++i) tail; < i 1; + head = i (size_t for 0) > (size if { Deque<T>::print_to_console() void inline T> template<typename } пустой!\n"; "Дек << std::cout else '; ' << data[i] << file ++i) tail; < i 1; + head = i (size_t for 0) > (size if { file) Deque<T>::print_to_file(std::ofstream& void inline T> template<typename } size; return { Deque<T>::get_size() size_t inline T> template<typename } 1]; - data[tail return дека!\n"); пустого из элемента извлечения std::out_of_range("Попытка throw (!size) if { Deque<T>::back() T inline T> template<typename } 1]; + data[head return дека!\n"); пустого из элемента извлечения std::out_of_range("Попытка throw (!size) if { Deque<T>::front() T inline T> template<typename } 1; - tail = head 2; / capacity = tail T[capacity]; new = data 2; + MAX_SIZE = capacity 0; = size data; //delete { Deque<T>::clear() void inline T> template<typename } !size; return { Deque<T>::empty() bool inline T> template<typename } ++size; value; = data[head--] extend(); свободна всегда ячейка 0-я // 1) <= 1 + (head if { value) T& Deque<T>::push_front(const void inline T> template<typename } ++size; value; = data[tail++] extend(); capacity) >= (tail if { value) T& Deque<T>::push_back(const void inline T> template<typename } push_front(value); value) >> (file while value; T clear(); { file) Deque<T>::init_by_push_front(std::ifstream& void inline T> template<typename } push_back(value); value) >> (file while value; T clear(); { file) Deque<T>::init_by_push_back(std::ifstream& void inline T> template<typename } tmp; = data data; delete[] } data[i]; = tmp[tail++] { ++i) size; + prev_head <= i prev_head; = i (int for head; = tail 2; / size - 2 / capacity = head head; = prev_head int T[capacity]; new = tmp T* 2; *= capacity { Deque<T>::extend() void inline T> template<typename раза 2 в памяти выделенной увеличение // } nullptr; = data data; delete[] 0; = size { Deque<T>::~Deque() inline T> template<typename } 1; - tail = head 2; / capacity = tail T[capacity]; new = data 2; + allocate_size = capacity { allocate_size) Deque<T>::Deque(size_t inline T> template<typename }; clear(); void empty(); bool пустоту на дека проверка // print_to_console(); void консоль на печать // file); print_to_file(std::ofstream& void стека очистки ез файл в печать // get_size(); size_t back(); T конца из значения //получение front(); T начала из значения получение // pop_front(); T начала из удаление // pop_back(); T конца из удаление // value); T& push_front(const void начало в добавление // value); T& push_back(const void конец в добавление // file); init_by_push_front(std::ifstream& void file); init_by_push_back(std::ifstream& void ~Deque(); MAX_SIZE); = allocate_size Deque(size_t размера вводимого проверку сделать TODO: // public: extend(); void размер фактический // size; size_t памяти выделенной размер // capacity; size_t tail; head, size_t data; T* 8; = MAX_SIZE size_t static const private: { Deque class T> <typename template "Time.h" #include <iostream> #include <fstream> #include once #pragma 